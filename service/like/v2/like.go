package like

import (
	"fmt"
	"reflect"
	"time"

	"github.com/mitchellh/mapstructure"
	"github.com/teejays/clog"

	"github.com/teejays/matchapi/db"
	"github.com/teejays/matchapi/lib/pk"
	"github.com/teejays/matchapi/service/user/v1"
)

// BasicLike represents the part of Like struct that is generated by the user behavior
type BasicLike struct {
	ReceiverID pk.ID
}

// Like represents the like action
type Like struct {
	ID        pk.ID
	GiverID   pk.ID
	Datetime  time.Time
	IsDeleted bool
	BasicLike `mapstructure:",squash"`
}

// IncomingLike represents a Like object but information tailored towards the receiver of the like
type IncomingLike struct {
	Giver user.ShareableProfile
	Like
}

// Validate returns error if the data in the BasicLike is not valid
func (b BasicLike) Validate() error {

	// ReceiverID should be greater than zero
	if b.ReceiverID < 1 {
		return fmt.Errorf("invalid ReceiverID: should be greater than 0")
	}

	clog.Debugf("BasicLike.Validate(): ReceiverId: %v", b.ReceiverID)

	// ReceiverID should be a valid user
	u, err := user.GetUserByID(b.ReceiverID)
	if err != nil {
		return fmt.Errorf("invalid ReceiverID: could not validate that a user exists with this userID: %v", err)
	}
	if u == nil {
		return fmt.Errorf("invalid ReceiverID: no user found with this userID")
	}

	return nil

}

// NewLike registers a new like in the database
func NewLike(userID pk.ID, b BasicLike) (Like, error) {

	// Create a new Like object
	var l Like
	l.BasicLike = b
	l.GiverID = userID
	l.Datetime = time.Now()

	// Validate that the data is okay
	if err := b.Validate(); err != nil {
		return l, fmt.Errorf("could not validate the data: %v", err)
	}

	// Save the object in the DB
	id, err := db.SaveNewEntity(db.LikeCollection, &l)
	if err != nil {
		return l, err
	}

	var like Like
	err = db.GetEntityByID(db.LikeCollection, id, &like)
	if err != nil {
		return like, err
	}

	return like, nil
}

// GetIncomingLikesByUserID returns all the users that have like the provided UserID
func GetIncomingLikesByUserID(id pk.ID) ([]IncomingLike, error) {
	var incomingLikes = []IncomingLike{}

	// Get all the likes received by this user
	likes, err := getLikesByReceiverID(id)
	if err != nil {
		return nil, err
	}

	//
	for _, l := range likes {
		if l.ReceiverID != id {
			panic("an unexpected entity found in the search result")
		}
		giver, err := user.GetUserByID(l.GiverID)
		if err != nil {
			clog.Warnf("There was an error trying GetUserByID(%d): %v", l.GiverID, err)
			continue
		}
		var incomingLike IncomingLike
		incomingLike.Like = l
		incomingLike.Giver = giver.ShareableProfile
		incomingLikes = append(incomingLikes, incomingLike)
	}

	return incomingLikes, nil
}

func getLikesByReceiverID(id pk.ID) ([]Like, error) {

	// Run the query
	result, err := db.Query(db.LikeCollection, fmt.Sprintf("ReceiverID:%d", id))
	if err != nil {
		return nil, err
	}

	// Convert the result into likes
	var likes []Like
	stringToDateTimeHook := func(
		f reflect.Type,
		t reflect.Type,
		data interface{}) (interface{}, error) {
		if t == reflect.TypeOf(time.Time{}) && f == reflect.TypeOf("") {
			return time.Parse(time.RFC3339, data.(string))
		}

		return data, nil
	}
	config := mapstructure.DecoderConfig{
		DecodeHook: stringToDateTimeHook,
		Result:     &likes,
	}

	decoder, err := mapstructure.NewDecoder(&config)
	if err != nil {
		return nil, err
	}
	err = decoder.Decode(result)
	if err != nil {
		return nil, fmt.Errorf("could not convert map to a struct: %v", err)
	}

	clog.Debugf("%+v", likes)

	return likes, nil
}
