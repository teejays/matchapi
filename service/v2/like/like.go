package like

import (
	"fmt"
	"reflect"
	"time"

	"github.com/mitchellh/mapstructure"
	"github.com/teejays/clog"

	"github.com/teejays/matchapi/db"
	"github.com/teejays/matchapi/lib/pk"
	"github.com/teejays/matchapi/service/v1/user"
)

// BasicLike represents the part of Like struct that is generated by the user behavior
type BasicLike struct {
	ReceiverID pk.ID
}

// Like represents the like action
type Like struct {
	ID        pk.ID
	GiverID   pk.ID
	Datetime  time.Time
	IsDeleted bool
	BasicLike `mapstructure:",squash"`
}

// IncomingLike represents a Like object but information tailored towards the receiver of the like
type IncomingLike struct {
	Giver user.ShareableProfile
	Like
}

func (b BasicLike) validate() error {

	// ReceiverID should be greater than zero
	if b.ReceiverID < 1 {
		return fmt.Errorf("invalid ReceiverID: should be greater than 0")
	}

	// ReceiverID should be a valid user
	u, err := user.GetUserByID(b.ReceiverID)
	if err != nil {
		return fmt.Errorf("invalid ReceiverID: could not validate that a user exists with this userID")
	}
	if u == nil {
		return fmt.Errorf("invalid ReceiverID: no user found with this userID")
	}

	return nil

}

// NewLike registers a new like in the database
func NewLike(userID pk.ID, b BasicLike) (Like, error) {

	// Create a new Like object
	var l Like
	l.BasicLike = b
	l.GiverID = userID
	l.Datetime = time.Now()

	// Validate that the data is okay
	if err := b.validate(); err != nil {
		return l, fmt.Errorf("could not validate the data: %v", err)
	}

	// Save the object in the DB
	id, err := db.SaveNewEntity(db.LikeCollection, &l)
	if err != nil {
		return l, err
	}

	var like Like
	err = db.GetEntityByID(db.LikeCollection, id, &like)
	if err != nil {
		return like, err
	}

	return like, nil
}

// GetIncomingLikesByUserID returns all the users that have like the provided UserID
func GetIncomingLikesByUserID(id pk.ID) ([]IncomingLike, error) {
	var incomingLikes = []IncomingLike{}

	// Get all the likes received by this user
	likes, err := getLikesByReceiverID(id)
	if err != nil {
		return nil, err
	}

	//
	for _, l := range likes {
		if l.ReceiverID != id {
			panic("an unexpected entity found in the search result")
		}
		giver, err := user.GetUserByID(l.GiverID)
		if err != nil {
			clog.Warnf("There was an error trying GetUserByID(%d): %v", l.GiverID, err)
			continue
		}
		var incomingLike IncomingLike
		incomingLike.Like = l
		incomingLike.Giver = giver.ShareableProfile
		incomingLikes = append(incomingLikes, incomingLike)
	}

	return incomingLikes, nil
}

func getLikesByReceiverID(id pk.ID) ([]Like, error) {

	// run the query
	result, err := db.Query(db.LikeCollection, fmt.Sprintf("ReceiverID:%d", id))
	if err != nil {
		return nil, err
	}

	// convert the result into likes
	var likes []Like
	for _, r := range result {
		_r, ok := r.(map[string]interface{})
		if !ok {
			return nil, fmt.Errorf("could not assert a search result as a map[string]interface{}")
		}
		clog.Infof("%v", _r)
		var l Like
		stringToDateTimeHook := func(
			f reflect.Type,
			t reflect.Type,
			data interface{}) (interface{}, error) {
			if t == reflect.TypeOf(time.Time{}) && f == reflect.TypeOf("") {
				return time.Parse(time.RFC3339, data.(string))
			}

			return data, nil
		}
		config := mapstructure.DecoderConfig{
			DecodeHook: stringToDateTimeHook,
			Result:     &l,
		}

		decoder, err := mapstructure.NewDecoder(&config)
		if err != nil {
			return nil, err
		}
		err = decoder.Decode(_r)
		if err != nil {
			return nil, fmt.Errorf("could not convert map to a struct: %v", err)
		}
		clog.Infof("%+v", l)
		likes = append(likes, l)
	}

	return likes, nil
}

var mockLikes = map[int]Like{
	1: Like{
		GiverID:  2,
		Datetime: time.Now(),
		BasicLike: BasicLike{
			ReceiverID: 1,
		},
	},
	2: Like{
		GiverID:  3,
		Datetime: time.Now(),
		BasicLike: BasicLike{
			ReceiverID: 1,
		},
	},
	3: Like{
		GiverID:  3,
		Datetime: time.Now(),
		BasicLike: BasicLike{
			ReceiverID: 2,
		},
	},
}
